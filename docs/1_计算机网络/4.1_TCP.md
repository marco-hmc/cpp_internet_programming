---
layout: post
title: （五）计网那些事儿：传输层-tcp
categories: 计算机网络
related_posts: True
tags: network
toc:
  sidebar: right
---

## TCP 协议详解 - 可靠传输的实现者

- 理解 TCP 协议要解决的核心问题
- 掌握 TCP 连接建立和断开的过程
- 了解 TCP 可靠传输的实现机制
- 认识 TCP 在实际应用中的重要作用
- 理解 TCP 性能优化的基本原理

---

### 1. 为什么需要 TCP？要解决什么问题？

#### 🤔 **现实问题引入**

想象你在网上购买一本书：

- **问题 1**: 你的订单信息不能丢失，否则钱付了却收不到书
- **问题 2**: 订单信息不能重复，否则可能被扣款两次
- **问题 3**: 订单信息不能乱序，否则可能先收到书再付款
- **问题 4**: 如果网络繁忙，不能让电商网站崩溃

这些就是 TCP 要解决的核心问题：**在不可靠的网络上提供可靠的传输服务**

#### 📊 **TCP 要解决的四大问题**

| 问题         | 网络现实情况       | TCP 解决方案 | 实际应用             |
| ------------ | ------------------ | ------------ | -------------------- |
| **数据丢失** | 网络拥塞、设备故障 | 超时重传机制 | 文件下载、网页浏览   |
| **数据重复** | 网络抖动导致重传   | 序号去重机制 | 在线支付、数据库操作 |
| **数据乱序** | 不同路径传输延迟   | 序号排序机制 | 视频播放、文件传输   |
| **网络拥塞** | 发送过快导致阻塞   | 拥塞控制算法 | 保护网络基础设施     |

#### 🔍 **TCP 的核心特点**

```
TCP = 传输控制协议 (Transmission Control Protocol)

核心特点：
✅ 面向连接 - 通信前先建立连接
✅ 可靠传输 - 保证数据完整准确到达
✅ 有序传输 - 保证数据按发送顺序到达
✅ 流量控制 - 防止发送方过快导致接收方处理不过来
✅ 拥塞控制 - 防止网络过载
```

---

### 2. TCP 报文结构 - 控制信息的载体

#### 📦 **TCP 报文头部结构**

![TCP报文结构](imgs/4.1_TCP_image-1.png)

##### **重要字段解析**

| 字段            | 长度  | 作用                 | 实际意义             |
| --------------- | ----- | -------------------- | -------------------- |
| **序号(Seq)**   | 32 位 | 标识字节流位置       | 防止乱序，支持重组   |
| **确认号(Ack)** | 32 位 | 期望接收的下一个序号 | 确认机制，支持重传   |
| **窗口大小**    | 16 位 | 接收缓冲区剩余空间   | 流量控制             |
| **标志位**      | 6 位  | 控制连接状态         | 建立、维护、断开连接 |

##### **关键标志位**

```
SYN (Synchronize)     = 1: 连接请求/建立
ACK (Acknowledgment)  = 1: 确认有效
FIN (Finish)         = 1: 连接终止
RST (Reset)          = 1: 连接重置
PSH (Push)           = 1: 立即推送
URG (Urgent)         = 1: 紧急数据
```

---

### 3. TCP 连接管理 - 三次握手与四次挥手

#### 🤝 **三次握手 - 解决连接建立问题**

**要解决的问题**: 如何在不可靠网络上可靠地建立连接？

##### **三次握手过程**

![三次握手](imgs/4.1_TCP_image.png)

```
客户端                           服务器
   │                               │
   ├─ SYN(seq=x) ─────────────────→│  第一次握手："我想连接"
   │                               │
   │←───────── SYN+ACK(seq=y,ack=x+1)│  第二次握手："好的，我也想连接"
   │                               │
   ├─ ACK(ack=y+1) ───────────────→│  第三次握手："确认建立连接"
   │                               │
  连接建立，开始数据传输
```

##### **为什么需要三次握手？**

**两次握手的问题**:

```
问题场景：网络延迟导致的重复连接
1. 客户端发送连接请求A，但网络延迟很大
2. 客户端超时，重新发送连接请求B
3. 请求B先到达，建立连接，完成通信，关闭连接
4. 延迟的请求A到达服务器
5. 如果只有两次握手，服务器会错误建立第二个连接
6. 浪费服务器资源，可能导致服务器过载
```

**三次握手解决方案**:

```
1. 服务器收到延迟的请求A，发送确认
2. 客户端收到确认，但知道这是旧请求，不发送第三次确认
3. 服务器收不到第三次确认，不建立连接
4. 避免了资源浪费
```

##### **实际应用示例**

```bash
# 使用telnet观察三次握手
telnet www.baidu.com 80

# 使用tcpdump抓包观察
tcpdump -i any -n port 80
```

#### 👋 **四次挥手 - 解决连接断开问题**

**要解决的问题**: 如何优雅地断开连接，确保数据传输完成？

##### **四次挥手过程**

```
客户端                           服务器
   │                               │
   ├─ FIN(seq=u) ─────────────────→│  第一次挥手："我没数据要发了"
   │                               │
   │←─────────── ACK(ack=u+1) ─────┤  第二次挥手："我知道了"
   │                               │
   │←────── FIN+ACK(seq=v,ack=u+1) ┤  第三次挥手："我也没数据要发了"
   │                               │
   ├─ ACK(ack=v+1) ───────────────→│  第四次挥手："确认断开"
   │                               │
 等待2MSL后关闭               立即关闭
```

##### **为什么需要四次挥手？**

**TCP 是全双工通信**:

```
客户端到服务器方向：第一、二次挥手关闭
服务器到客户端方向：第三、四次挥手关闭

这样确保两个方向的数据都传输完成
```

##### **TIME_WAIT 状态的意义**

**要解决的问题**: 最后一个 ACK 丢失怎么办？

```
TIME_WAIT = 2MSL (Maximum Segment Lifetime)

作用1: 确保最后的ACK能被对方收到
- 如果ACK丢失，对方会重发FIN
- 在2MSL时间内可以接收并重新发送ACK

作用2: 确保旧连接的数据包在网络中消失
- 防止旧连接的数据包影响新连接
- 保证新连接的数据纯净性
```

---

### 4. TCP 可靠传输机制

#### 🔢 **序号机制 - 解决数据顺序问题**

**要解决的问题**: 网络中数据包可能乱序到达，如何保证顺序？

##### **序号工作原理**

```
发送方：给每个字节分配序号
数据: "Hello World"
序号: 1001  1002  1003  1004  1005  1006  1007  1008  1009  1010  1011

分片传输:
包1: seq=1001, data="Hello" (1001-1005)
包2: seq=1006, data=" World" (1006-1011)

接收方：根据序号重组数据
收到: 包2先到达, 包1后到达
处理: 根据序号排序，重组为"Hello World"
确认: 发送ACK=1012 (期望下一个字节序号)
```

##### **实际应用示例**

```python
# 模拟TCP序号机制的简单示例
class TCPReceiver:
    def __init__(self):
        self.expected_seq = 1000
        self.buffer = {}
        self.received_data = ""

    def receive_packet(self, seq, data):
        if seq == self.expected_seq:
            # 按序到达，直接处理
            self.received_data += data
            self.expected_seq += len(data)
            # 检查缓存中是否有后续数据
            self.check_buffer()
        else:
            # 乱序到达，放入缓存
            self.buffer[seq] = data

    def check_buffer(self):
        while self.expected_seq in self.buffer:
            data = self.buffer.pop(self.expected_seq)
            self.received_data += data
            self.expected_seq += len(data)
```

#### ✅ **确认机制 - 解决数据丢失问题**

**要解决的问题**: 网络不可靠，数据包可能丢失，如何确保到达？

##### **累积确认机制**

```
发送方发送: 包1(seq=100), 包2(seq=200), 包3(seq=300)

正常情况:
接收方: 收到包1 → 发送ACK=200
接收方: 收到包2 → 发送ACK=300
接收方: 收到包3 → 发送ACK=400

包2丢失情况:
接收方: 收到包1 → 发送ACK=200
接收方: 收到包3 → 仍发送ACK=200 (累积确认)
发送方: 收到重复ACK，知道包2丢失，重传包2
```

#### ⏰ **超时重传 - 解决网络延迟问题**

**要解决的问题**: 数据包丢失或网络延迟时，如何重新传输？

##### **自适应重传算法**

```
RTT估算: 动态计算往返时间
RTO计算: 超时时间 = RTT + 4 × RTT偏差

超时重传策略:
1. 发送数据包，启动定时器
2. 收到ACK，停止定时器
3. 超时未收到ACK，重传数据包
4. 指数退避：第一次1秒，第二次2秒，第三次4秒...
```

##### **快重传机制**

```
发送方: 发送包1, 包2, 包3, 包4, 包5
网络:   包1✓, 包2✗, 包3✓, 包4✓, 包5✓

接收方响应:
收到包1 → 发送ACK=2 ✓
收到包3 → 发送ACK=2 (重复)
收到包4 → 发送ACK=2 (重复)
收到包5 → 发送ACK=2 (重复)

发送方: 收到3个重复ACK → 立即重传包2 (不等超时)
```

#### 🌊 **流量控制 - 解决处理能力不匹配问题**

**要解决的问题**: 发送方太快，接收方处理不过来怎么办？

##### **滑动窗口机制**

```
接收方窗口通告:
"我的缓冲区还有1000字节空间"

发送方响应:
"好的，我最多发送1000字节"

动态调整:
接收方处理了500字节 → 通告"还有1500字节空间"
发送方 → 可以继续发送更多数据
```

##### **零窗口处理**

```
问题: 接收方缓冲区满了，发送窗口为0
解决: 坚持定时器
1. 接收方发送窗口大小为0的ACK
2. 发送方停止发送，启动坚持计时器
3. 定时器到期，发送零窗口探测包
4. 接收方回复当前窗口大小
5. 如果窗口仍为0，继续等待；否则恢复发送
```

#### 🚦 **拥塞控制 - 解决网络过载问题**

**要解决的问题**: 如何避免发送过快导致网络拥塞？

##### **拥塞控制算法**

**1. 慢启动 (Slow Start)**

```
问题: 不知道网络能承受多大流量
解决: 指数增长试探

cwnd = 1      发送1个包
收到ACK → cwnd = 2      发送2个包
收到ACK → cwnd = 4      发送4个包
收到ACK → cwnd = 8      发送8个包
...
```

**2. 拥塞避免 (Congestion Avoidance)**

```
当 cwnd >= ssthresh 时:
改为线性增长，每次只增加1

cwnd = 8 → cwnd = 9 → cwnd = 10 → ...
避免增长过快导致网络拥塞
```

**3. 快重传和快恢复**

```
检测到丢包时:
1. ssthresh = cwnd / 2  (阈值减半)
2. cwnd = ssthresh + 3  (快恢复)
3. 重传丢失的包
4. 继续线性增长

这比慢启动更快地恢复到合适的发送速率
```

##### **实际应用示例**

```bash
# 查看TCP拥塞控制算法
cat /proc/sys/net/ipv4/tcp_congestion_control

# 查看连接的拥塞窗口大小
ss -i | grep cwnd

# 设置拥塞控制算法
echo cubic > /proc/sys/net/ipv4/tcp_congestion_control
```

---

### 5. TCP 在实际应用中的体现

#### 🌐 **Web 浏览 (HTTP over TCP)**

##### **为什么 HTTP 需要 TCP？**

```
用户需求: 完整正确地加载网页
网页组成: HTML + CSS + JavaScript + 图片

TCP保证:
✅ HTML文件完整下载
✅ CSS样式不丢失
✅ JavaScript脚本按顺序执行
✅ 图片数据完整显示
```

##### **HTTP/1.1 持久连接**

```bash
# HTTP/1.0: 每个资源一个TCP连接
请求index.html → 建立连接 → 传输 → 断开连接
请求style.css → 建立连接 → 传输 → 断开连接
请求script.js → 建立连接 → 传输 → 断开连接

# HTTP/1.1: 复用TCP连接
建立连接 → 请求index.html → 请求style.css → 请求script.js → 断开连接

# 查看HTTP连接复用
curl -v -H "Connection: keep-alive" http://example.com
```

#### 📧 **电子邮件 (SMTP/POP3/IMAP over TCP)**

```
邮件发送流程 (SMTP over TCP):
1. 客户端与SMTP服务器建立TCP连接
2. 身份验证 → 必须可靠传输
3. 邮件内容传输 → 不能丢失任何字符
4. 传输确认 → 确保邮件已发送

邮件接收流程 (POP3/IMAP over TCP):
1. 与邮件服务器建立TCP连接
2. 邮件列表下载 → 必须完整
3. 邮件内容下载 → 不能损坏
4. 邮件状态同步 → 防止重复下载
```

#### 💰 **在线支付系统**

##### **为什么支付必须用 TCP？**

```
支付流程的可靠性要求:
1. 支付请求 → 不能丢失 (否则扣款不成功)
2. 支付确认 → 不能重复 (否则重复扣款)
3. 余额查询 → 必须准确 (否则显示错误余额)
4. 交易记录 → 必须完整 (否则无法对账)

TCP保证:
✅ 每个支付请求都能到达
✅ 支付状态准确返回
✅ 交易金额不会出错
✅ 网络拥塞时自动降速保护系统
```

#### 🎮 **在线游戏的不同需求**

```
游戏类型对比:

回合制游戏 (如棋牌):
需求: 操作指令不能丢失，顺序很重要
选择: TCP
原因: 走棋步骤必须准确，宁可慢一点也要正确

实时对战游戏 (如FPS):
需求: 低延迟比完整性更重要
选择: UDP + 应用层可靠性
原因: 玩家位置更新允许丢失，但延迟必须低

MMO游戏:
聊天系统 → TCP (消息不能丢失)
位置同步 → UDP (实时性重要)
交易系统 → TCP (金币道具不能丢失)
```

---

### 6. TCP 性能优化

#### ⚡ **Nagle 算法 - 解决小包问题**

**要解决的问题**: 应用频繁发送小数据包导致网络效率低

```
问题场景:
应用发送: "H" "e" "l" "l" "o"
网络传输: [TCP头20字节+"H"1字节] [TCP头20字节+"e"1字节] ...
效率: 1/21 = 4.7%

Nagle算法解决:
1. 收集小数据包到一定大小再发送
2. 或等待上一个包的ACK再发送
结果: [TCP头20字节+"Hello"5字节]
效率: 5/25 = 20%

禁用Nagle (实时应用):
setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(flag));
```

#### 🚀 **TCP Fast Open - 减少连接延迟**

**要解决的问题**: 三次握手增加了连接建立时间

```
传统TCP:
客户端 → SYN → 服务器 (1 RTT)
客户端 ← SYN+ACK ← 服务器
客户端 → ACK → 服务器
客户端 → HTTP请求 → 服务器 (1 RTT)
总计: 2 RTT

TCP Fast Open:
客户端 → SYN+Cookie+HTTP请求 → 服务器 (1 RTT)
客户端 ← SYN+ACK+HTTP响应 ← 服务器
总计: 1 RTT

启用TFO:
echo 3 > /proc/sys/net/ipv4/tcp_fastopen
```

#### 📊 **TCP 窗口缩放 - 支持高带宽**

**要解决的问题**: 16 位窗口字段最大只能表示 64KB

```
高带宽长延迟网络 (如卫星网络):
带宽: 100Mbps
延迟: 500ms
需要缓冲: 100Mbps × 500ms = 6.25MB

但TCP窗口最大: 64KB << 6.25MB

窗口缩放解决:
在TCP选项中协商缩放因子
实际窗口 = 窗口字段值 × 2^缩放因子
最大支持: 64KB × 2^14 = 1GB

启用窗口缩放:
echo 1 > /proc/sys/net/ipv4/tcp_window_scaling
```

---

### 7. TCP 故障排查

#### 🔍 **常见 TCP 问题诊断**

##### **连接建立问题**

```bash
# 检查端口是否监听
netstat -tulpn | grep :80
ss -tulpn | grep :80

# 测试连接
telnet server.com 80
nc -zv server.com 80

# 抓包分析三次握手
tcpdump -i any -n port 80 and host server.com
```

##### **性能问题分析**

```bash
# 查看TCP连接状态统计
ss -s

# 查看重传统计
netstat -s | grep -i retrans

# 查看拥塞控制信息
ss -i sport :80

# 实时监控连接
watch 'ss -tuln | grep :80'
```

##### **TIME_WAIT 过多问题**

```bash
# 查看TIME_WAIT连接数
ss -ant | grep TIME-WAIT | wc -l

# 优化TIME_WAIT设置
echo 1 > /proc/sys/net/ipv4/tcp_tw_reuse
echo 1 > /proc/sys/net/ipv4/tcp_tw_recycle  # 慎用

# 应用层解决方案
# 1. 让客户端主动断开连接
# 2. 使用连接池
# 3. 使用HTTP/1.1 keep-alive
```

---

### 8. 粘包问题 - TCP 流式传输的挑战

#### 🤔 **什么是粘包？为什么会产生？**

**要解决的问题**: TCP 是字节流协议，没有消息边界

##### **粘包产生原因**

```
TCP特性: 面向字节流，不是面向消息

发送方:
app.send("Hello")
app.send("World")

网络传输: 可能合并为一个TCP段
接收方收到: "HelloWorld"

问题: 接收方不知道哪里是"Hello"结束，哪里是"World"开始
```

##### **粘包场景示例**

```python
# 发送方代码
import socket
import time

sock = socket.socket()
sock.connect(('localhost', 8080))

# 快速发送多个小消息
sock.send(b"MSG1")
sock.send(b"MSG2")
sock.send(b"MSG3")
sock.close()

# 接收方可能收到: b"MSG1MSG2MSG3"
# 或者: b"MSG1" + b"MSG2MSG3"
# 或者: b"MSG1MSG2" + b"MSG3"
```

#### 🛠️ **粘包解决方案**

##### **方案 1: 固定长度消息**

```python
# 每个消息固定10字节
def send_fixed_message(sock, msg):
    # 不足10字节用空格填充
    padded_msg = msg.ljust(10)[:10]
    sock.send(padded_msg.encode())

def recv_fixed_message(sock):
    # 固定接收10字节
    data = sock.recv(10)
    return data.decode().rstrip()
```

##### **方案 2: 消息长度前缀**

```python
import struct

def send_length_prefixed(sock, msg):
    # 4字节长度 + 消息内容
    data = msg.encode()
    length = len(data)
    sock.send(struct.pack('!I', length) + data)

def recv_length_prefixed(sock):
    # 先接收4字节长度
    length_data = sock.recv(4)
    if len(length_data) < 4:
        return None
    length = struct.unpack('!I', length_data)[0]

    # 再接收指定长度的数据
    data = b''
    while len(data) < length:
        chunk = sock.recv(length - len(data))
        if not chunk:
            break
        data += chunk

    return data.decode()
```

##### **方案 3: 消息分隔符**

```python
def send_delimited(sock, msg):
    # 使用换行符作为分隔符
    sock.send((msg + '\n').encode())

def recv_delimited(sock):
    buffer = b''
    while True:
        chunk = sock.recv(1024)
        if not chunk:
            break
        buffer += chunk

        # 查找分隔符
        while b'\n' in buffer:
            line, buffer = buffer.split(b'\n', 1)
            yield line.decode()
```

---

### 📚 学习总结

#### ✅ **核心要点回顾**

1. **问题导向理解**: TCP 解决网络不可靠性问题
2. **连接管理**: 三次握手建立，四次挥手断开
3. **可靠传输**: 序号、确认、重传机制
4. **流量控制**: 滑动窗口防止接收方过载
5. **拥塞控制**: 慢启动、拥塞避免保护网络
6. **实际应用**: Web、邮件、支付等场景的必需品

#### 🎯 **实践建议**

1. **动手实验**:

   - 编写简单的 TCP 客户端服务器程序
   - 使用 Wireshark 观察 TCP 协议行为
   - 模拟网络丢包测试 TCP 重传

2. **工具掌握**:

   - 网络命令: netstat, ss, tcpdump
   - 编程接口: socket API, setsockopt
   - 监控工具: iftop, nethogs

3. **问题解决**:
   - 理解粘包问题并实现解决方案
   - 学会诊断 TCP 性能问题
   - 掌握 TCP 参数调优

#### 🔍 **深入学习方向**

- **TCP 变种**: TCP Reno, Cubic, BBR 等拥塞控制算法
- **高性能 TCP**: TCP 优化、内核参数调优
- **现代替代**: QUIC 协议、HTTP/3
- **网络编程**: 异步 IO、epoll、多路复用

---

> **💡 学习提示**: TCP 是互联网的基石协议，理解其设计思想对于网络编程和系统设计都非常重要。建议通过实际编程和网络抓包来加深理解，特别关注 TCP 如何在不可靠网络上构建可靠服务的设计哲学。

#### 99. quiz

##### 1. TCP 协议如何保证可靠传输?

> [TCP 协议如何保证可靠传输](https://snailclimb.gitee.io/javaguide/#/./docs/cs-basics/network/other-network-questions?id=tcp-%e5%8d%8f%e8%ae%ae%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e5%8f%af%e9%9d%a0%e4%bc%a0%e8%be%93)

##### 2. 为什么要等待 2MSL?

- **保证客户端发送的最后一个 ACK 报文能够到达服务器**,因为这个 ACK 报文可能丢失,服务器已经发送了 FIN+ACK 报文,请求断开,客户端却没有回应,于是服务器又会重新发送一次,而客户端就能在这个 2MSL 时间段内收到这个重传的报文,接着给出回应报文,并且会重启 2MSL 计时器
- 防止类似与"三次握手"中提到了的"已经失效的连接请求报文段"出现在本连接中.客户端发送完最后一个确认报文后,在这个 2MSL 时间中,就可以**使本连接持续的时间内所产生的所有报文段(被动关闭方延时到来的 FIN 报文)都从网络中消失(指的是在路由器的缓存失效),这样新的连接中不会出现旧连接的请求报文**

##### 3. time_waitd 和 close_wait 的影响,以及如何避免?

[time_wait 和 close_wait](https://www.cnblogs.com/kevingrace/p/9988354.html)

##### 4. TCP 最后一次 ack 如果客户端没有收到怎么办

如果 TCP 的最后一次 ACK（确认）包客户端没有收到，那么发送方（通常是服务器）会认为最后的数据包没有被成功接收，因此会启动重传机制。

TCP 使用了一种称为“超时重传”（Timeout Retransmission）的机制来处理这种情况。具体来说，每当 TCP 发送一个数据包，它都会启动一个定时器。如果在定时器到期之前没有收到 ACK，TCP 会认为这个数据包丢失，然后重新发送这个数据包。

这种机制确保了 TCP 的可靠性，即使在网络环境不稳定的情况下，TCP 也能保证数据的完整性和准确性。但是，这也可能导致网络的拥塞，因此 TCP 还需要使用拥塞控制机制来防止网络的过度拥塞。

##### 5. 服务器出现大量 close_wait 的连接的原因以及解决方法

close_wait 状态是在 TCP 四次挥手的时候收到 FIN 但是没有发送自己的 FIN 时出现的,服务器出现大量 close_wait 状态的原因有两种:

- 服务器内部业务处理占用了过多时间,都没能处理完业务;或者还有数据需要发送;或者服务器的业务逻辑有问题,没有执行 close()方法
- 服务器的父进程派生出子进程,子进程继承了 socket,收到 FIN 的时候子进程处理但父进程没有处理该信号,导致 socket 的引用不为 0 无法回收

处理方法:

- 停止应用程序
- 修改程序里的 bug

##### 6. tcpdump

- [抓包工具 tcpdump](https://www.cnblogs.com/f-ck-need-u/p/7064286.html) 以后抓包要经常用。<br>

##### 7. 为什么使用三次握手,两次握手可不可以?

如果使用两次握手的话,三次握手中的最后一次缺失,服务器不能确认客户端的接收能力.

举两个例子,第一种是黑客会伪造大量 SYN 请求发送给服务器,服务器立即确认并建立连接,分配资源,但是这一系列连接并不是真实存在的,这大大浪费了服务器的资源并且阻塞了正常用户的连接,这种也叫 SYN 洪泛攻击.第二种是服务器返回给客户端的 ACK 数据包可能会在传输的过程中丢失,而客户端没有收到该 ACK 数据包而拒绝接收服务器接下来发送的数据,于是服务器一直在发送,客户端一直在拒绝,形成死锁.

##### 8. TIME_WAIT 的意义(为什么要等于 2MSL)

TIME_WAIT 是指四次挥手中客户端接收了服务端的 FIN 报文并发送 ACK 报文给服务器后,仍然需要等待 2MSL 时间的过程.虽然按道理,四个报文都发送完毕,我们可以直接进入 CLOSE 状态了,但是我们必须假象网络是不可靠的,有可以最后一个 ACK 丢失.如果客户端发送的 ACK 发生丢失,服务器会再次发送 FIN 报文给客户端,所以 TIME_WAIT 状态就是用来重发可能丢失的 ACK 报文.

##### 9. 为什么 TCP 挥手每两次中间有一个 FIN-WAIT2 等待时间?

- 主动关闭的一端调用完 close 以后(即发 FIN 给被动关闭的一端, 并且收到其对 FIN 的确认 ACK)则进入 FIN_WAIT_2 状态.**如果这个时候因为网络突然断掉/被动关闭的一段宕机等原因,导致主动关闭的一端不能收到被动关闭的一端发来的 FIN(防止对端不发送关闭连接的 FIN 包给本端)**,这个时候就需要 FIN_WAIT_2 定时器, **如果在该定时器超时的时候,还是没收到被动关闭一端发来的 FIN,那么直接释放这个链接,进入 CLOSE 状态**

##### 10. TCP 是如何保证可靠传输的?

- **三次握手建立连接**(标志位):通信前确认通信实体存在,并且双方可以正确发送和接收对方的信息
- **序号机制**(序号/确认号):确保了数据是按序/完整到达
- **数据校验**(校验和):**CRC 校验全部数据,保证数据完整性和正确性**
- **超时重传**(定时器):保证因链路故障未能到达数据能够被多次重发
- **窗口机制**(窗口):提供**流量控制**,避免过量发送
- **拥塞控制**:使用拥塞窗口机制,控制发送窗口大小,减少网络拥塞,避免因网络拥塞导致频繁丢包

##### 11. TCP 收到 RST 包的几种情况

- **访问不存在的端口**
  - **试图与不被监听的端口建立连接,则直接返回 RST**,同时 RST 报文接收通告窗口大小为 0
  - 客户端向服务器的某个端口发起连接,如果端口被**处于 TIME_WAIT 状态的连接占用时**,客户端也会收到 RST
- **异常终止连接**
  - 一方直接发送 RST 报文,表示异常终止连接.**一旦发送方发送复位报文段,发送端所有排队等待发送的数据都被丢弃**.应用程序可以通过 socket 选项`SO_LINGER`(设置 `l_onoff`为 1,`l_linger`为 0)来发送 RST 复位报文
- **处理半打开连接**(**如果一方已经关闭或异常终止连接而另一方却还不知道,我们将这样的 TCP 连接称为半打开**(Half-Open))
  - 如 A 与 B 通信,**A 关闭了连接,B 却没有收到结束报文**(如网络故障),此时**B 还维持着原来的连接**.而 A 即使重启,也没有该连接的任何信息.**这种状态就叫做半打开连接**.而此时**B 往处于半打开状态的连接写数据,则对方回应 RST 复位报文**

##### 12. TCP keep-alive 和 http keep-alive 的区别

- **http Keep-Alive 模式**:

  - Http 协议采用"请求-应答"模式,当使用普通模式,即非 Keep-Alive 模式时,每个请求/应答,客户端和服务器都要新建一个连接,完成之后立即断开连接;当使用 Keep-Alive 模式时,Keep-Alive 功能使客户端到服务器端的连接持续有效,当出现对服务器的后继请求时,Keep-Alive 功能避免了建立或者重新建立连接
  - http1.0 中默认是关闭的,需要在 http 头加入"Connection: Keep-Alive",才能启用 Keep-Alive
  - http 1.1 中默认启用 Keep-Alive,如果加入"Connection: close "才关闭.目前大部分浏览器都是用 http1.1 协议,也就是说默认都会发起 Keep-Alive 的连接请求了,所以是否能完成一个完整的 Keep- Alive 连接就看服务器设置情况
  - 优点:Keep-Alive 模式更加高效,因为避免了连接建立和释放的开销
  - 缺点:长时间的 Tcp 连接容易导致系统资源无效占用,浪费系统资源

  - Keep-Alive timeout
    - Httpd 守护进程,一般都提供了 keep-alive timeout 时间设置参数.比如 nginx 的 keepalive_timeout,和 Apache 的 KeepAliveTimeout.这个 keepalive_timout 时间值意味着:**一个 http 产生的 tcp 连接在传送完最后一个响应后,还需要 hold 住 keepalive_timeout 秒后,才开始关闭这个连接**
    - 当 httpd 守护进程发送完一个响应后,理应马上主动关闭相应的 tcp 连接,设置 keepalive_timeout 后,httpd 守护进程会想说:"再等等吧,看看浏览器还有没有请求过来",这一等,便是 keepalive_timeout 时间.**如果守护进程在这个等待的时间里,一直没有收到浏览器发过来 http 请求,则关闭这个 http 连接**

- **Tcp 的 Keep-alive**
  - 连接建立之后,如果客户端一直不发送数据,或者隔很长时间才发送一次数据,当连接很久没有数据报文传输时如何去确定对方还在线,到底是掉线了还是确实没有数据传输,连接还需不需要保持,这种情况在 TCP 协议设计中是需要考虑到的
  - TCP 协议通过一种巧妙的方式去解决这个问题,**当超过一段时间之后,TCP 自动发送一个数据为空的报文(侦测包)给对方,如果对方回应了这个报文,说明对方还在线,连接可以继续保持,如果对方没有报文返回,并且重试了多次之后则认为链接丢失,没有必要保持连接**
  - tcp keep-alive 是 TCP 的一种检测 TCP 连接状况的保鲜机制.tcp keep-alive 保鲜定时器,支持三个系统内核配置参数:
    - net.ipv4.tcp_keepalive_intvl = 15
    - net.ipv4.tcp_keepalive_probes = 5
    - net.ipv4.tcp_keepalive_time = 7200
  - keepalive 是 TCP 保鲜定时器,当网络两端建立了 TCP 连接之后,闲置(双方没有任何数据流发送往来)了 tcp_keepalive_time 后,服务器就会尝试向客户端发送侦测包,来判断 TCP 连接状况(有可能客户端崩溃/强制关闭了应用/主机不可达等等)
  - 如果没有收到对方的回答(ack 包),则会在 tcp_keepalive_intvl 后再次尝试发送侦测包,直到收到对方的 ack,如果一直没有收到对方的 ack,一共会尝试 tcp_keepalive_probes 次,每次的间隔时间在这里分别是 15s, 30s, 45s, 60s, 75s.如果尝试 tcp_keepalive_probes,依然没有收到对方的 ack 包,则会丢弃该 TCP 连接.**TCP 连接默认闲置时间是 2 小时,一般设置为 30 分钟足够了**

##### 13. 当保持长连接时,如何判断一次请求已经完成?

- Content-Length:表示实体内容的长度.浏览器通过这个字段来判断当前请求的数据是否已经全部接收.所以,当浏览器请求的是一个静态资源时,即服务器能明确知道返回内容的长度时,可以设置 Content-Length 来控制请求的结束.**但当服务器并不知道请求结果的长度时,如一个动态的页面或者数据,Content-Length 就无法解决上面的问题,这个时候就需要用到 Transfer-Encoding 字段**
- Transfer-Encoding:**指传输编码**,在上面的问题中,当服务端无法知道实体内容的长度时,就可以通过指定 Transfer-Encoding: chunked 来告知浏览器当前的编码是将数据分成一块一块传递的.当然, 还可以指定`Transfer-Encoding: gzip, chunked`表明实体内容不仅是 gzip 压缩的,还是分块传递的.最后,**当浏览器接收到一个长度为 0 的 chunked 时**, 知道当前请求内容已全部接收

##### 14. TCP 和 UDP 是否可以绑定同一端口进行通信?

- 网络中可以被命名和寻址的通信端口,是操作系统可分配的一种资源
- 按照 OSI 七层协议的描述,传输层与网络层在功能上的最大区别是传输层提供进程通信能力.从这个意义上讲,网络通信的最终地址就不仅仅是主机地址了,还包括可以描述进程的某种标识符.为此,TCP/IP 协议提出了协议端口(protocol port,简称端口)的概念,用于标识通信的进程
- **端口是一种抽象的软件结构(包括一些数据结构和 I/O 缓冲区)**.应用程序(即进程)通过系统调用与某端口建立连接(binding)后,传输层传给该端口的数据都被相应进程所接收,相应进程发给传输层的数据都通过该端口输出.**在 TCP/IP 协议的实现中,端口操作类似于一般的 I/O 操作,进程获取一个端口,相当于获取本地唯一的 I/O 文件,可以用一般的读写原语访问之**
- **类似于文件描述符,每个端口都拥有一个叫端口号(port number)的整数型标识符,用于区别不同端口**.**由于 TCP/IP 传输层的两个协议 TCP 和 UDP 是完全独立的两个软件模块,因此各自的端口号也相互独立,如 TCP 有一个 255 号端口,UDP 也可以有一个 255 号端口,二者并不冲突**
- 端口号的分配是一个重要问题.**有两种基本分配方式**:
  - 第一种叫全局分配,这是一种集中控制方式,由一个公认的中央机构根据用户需要进行统一分配,并将结果公布于众
  - 第二种是本地分配,又称动态连接,即进程需要访问传输层服务时,向本地操作系统提出申请,操作系统返回一个本地唯一的端口号,进程再通过合适的系统调用将自己与该端口号联系起来(绑扎)
- TCP/IP 端口号的分配中综合了上述两种方式.TCP/IP 将端口号分为两部分,少量的作为保留端口,以全局方式分配给服务进程.因此,每一个标准服务器都拥有一个全局公认的端口(即周知口,well-known port),即使在不同机器上,其端口号也相同.剩余的为自由端口,以本地方式进行分配.TCP 和 UDP 均规定,小于 256 的端口号才能作保留端口

##### 15. 握手挥手中间有一次丢掉怎么办，处于什么状态？

##### 16. 套接字发送端确认发送出去了然后接收端收不到

我寻思有重传还能收不到，扯扯 nagle，后来说他们抓包发现被防火墙挡住了，看我简历里有写抓包啥的问我这个。

##### 17. tcp/udp 什么区别

tcp 自带心跳和应用层心跳啥的。

##### 18. 画出 tcp 头部的协议格式

##### 19. 滑动窗口的作用

答:主要就是为了实现流量控制,控制了发送包的速率,每次发送方只能发送滑动窗口内部的数据包,才能保证接收方不会因为发送过快造成流量淹没,数据包的丢失.他的大小是 拥塞窗口和通告窗口 两者的最小值.

##### 20. 慢启动曲线

慢启动,先发一个,可以就发两个,两个可以发四个,如此下去,遇到 sshread?那就线性,一个一个加,咦?拥塞了,丢包了?两种方案,快速重传或者将 shhresh 设为窗口的一半,然后又一个发,两个发,三个发,遇到 sshresh 的点,就一个一个发,这时就会看见网络卡顿.快速重传就将减半的 sshresh+3,然后又一个一个发.

##### 21. 三次握手的具体实现,time_wait 原理?

##### 22. tcp 以什么保证可靠

##### 23. tcp 数据校验是怎么做的

##### 24. 流量控制是怎么实现的?(滑动窗口)滑动窗口的大小具体是怎么变化的?

##### 25. 0.0.0.0 是什么网络地址?

在网络编程中,IP 地址`0.0.0.0`有特殊的含义,具体取决于上下文.

1. 在服务器编程中,如果一个服务器被告知监听`0.0.0.0`地址,那么它将在该机器的所有 IP 地址上监听传入的连接.这包括公共 IP 地址,私有 IP 地址,以及特殊的环回地址`127.0.0.1`.这样,无论客户端使用服务器的哪个 IP 地址来连接,服务器都可以接受连接.

2. 在路由表中,`0.0.0.0`通常用作默认路由的地址.这意味着,如果网络包的目标地址在路由表的其他条目中找不到匹配项,那么这个包将被发送到默认路由.

3. 在客户端编程中,`0.0.0.0`通常表示未指定的地址.例如,如果你告诉一个网络客户端连接到`0.0.0.0`,那么它通常会解释为"连接到本地主机".然而,这种行为并不总是一致的,因此通常不推荐这样做.

##### 26. TCP 的 nagle 算法和延迟 ack，还有 CORK 呢?他们有什么好处？一起用会有什么效果？你觉得可以有什么改进？

##### 27. 停止等待协议的缺点？拥塞控制的方式？快重传的时机是什么？

##### 28. 当接受方的接受窗口为 0 时还能接受数据吗？为什么？还能接受什么数据？那怎么处理这些数据呢？当接受方的返回的接受窗口为 0 时，发送方会进行什么操作？
