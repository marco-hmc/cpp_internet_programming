---
layout: post
title: （六）计网那些事儿：应用层-API网关
categories: 计算机网络
related_posts: True
tags: network
toc:
  sidebar: right
---

## API 网关 - 连接客户端与服务的总闸口

- 明确 API 网关为了解决什么问题
- 掌握 API 网关的核心能力与典型场景
- 能基于主流网关完成最小可用配置（路由/鉴权/限流/CORS/观测）
- 理解与负载均衡、服务网格、BFF 的边界与配合

---

### 1. 为什么需要 API 网关？要解决什么问题

现实痛点（从单体到微服务/多端接入后出现的通用问题）：

- 客户端直连多个服务，耦合重、变更成本高、协议不统一
- 身份认证、鉴权、限流、熔断、灰度、监控等横切能力重复造轮子
- 内部接口不宜直接暴露公网，安全风控与审计缺位
- 聚合接口（多服务组装）与协议转换（gRPC↔HTTP/JSON）需求强

API 网关的使命：

- 统一入口：对外一个域名/地址，对内灵活路由与编排
- 横切能力下沉：认证鉴权、流控熔断、观测审计、缓存、黑白名单
- 协议/格式转换：HTTP、gRPC、WebSocket、REST/JSON 到内部多协议
- 演进支点：灰度发布、A/B 测试、金丝雀流量、蓝绿切换

与其它组件的区别（简版）：

- L4 负载均衡：关注连接与传输（TCP/UDP）；API 网关是 L7（应用层）
- 服务网格（Service Mesh）：侧重服务间通信与治理；API 网关面向南北向（外部 ↔ 内部）
- BFF：为某类前端定制的网关/适配层；常与 API 网关配合使用

---

### 2. 基本概念与核心能力（不展开深原理）

- 路由与服务发现：基于路径/域名/头/方法等匹配，将请求转发给后端服务
- 认证与授权：JWT/OAuth2、API Key、HMAC 签名、mTLS
- 流量治理：限流（令牌桶/漏桶）、熔断、重试、超时、负载均衡策略
- 协议与数据转换：HTTP↔gRPC、请求/响应头与体重写、字段映射、压缩
- 安全与合规：WAF、IP 黑白名单、CORS、请求大小限制、敏感信息脱敏
- 缓存与加速：边缘/本地缓存、ETag/Cache-Control、响应体缓存
- 观测与审计：指标（Prometheus）、日志（结构化）、分布式追踪（Zipkin/Jaeger）
- 灰度与发布：按权重/用户/Header/地理/版本号路由

---

### 3. 典型应用场景

- 微服务统一入口：隐藏内部拓扑，聚合多服务为单一 API
- 多端接入与 BFF：为 Web/移动端/IoT 提供差异化 API 与网关策略
- 外网隔离与安全暴露：只暴露受控 API，统一接入审计
- 协议转换/遗留系统整合：对外 REST，对内 SOAP/gRPC
- 金丝雀与 A/B：按比例路由到新版本以验证稳定性
- 边缘网关/CDN 前置：就近接入、缓存、DDoS/WAF 联动

---

### 4. 实战示例（最小可用配置）

#### 4.1 Nginx/OpenResty（反向代理 + 限流 + CORS）

```nginx
# 基本反向代理与健康检查、限流、CORS
upstream svc_api {
    server 10.0.0.11:8080 max_fails=3 fail_timeout=10s;
    server 10.0.0.12:8080 max_fails=3 fail_timeout=10s;
    keepalive 64;
}

# 令牌桶限流：每秒10个请求，突发20
limit_req_zone $binary_remote_addr zone=perip:10m rate=10r/s;

server {
    listen 80;
    server_name api.example.com;

    # CORS
    add_header Access-Control-Allow-Origin *;
    add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
    add_header Access-Control-Allow-Headers "Authorization, Content-Type, X-Request-Id";
    if ($request_method = OPTIONS) { return 204; }

    location /api/ {
        proxy_set_header Host $host;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_read_timeout 30s;
        limit_req zone=perip burst=20 nodelay;
        proxy_pass http://svc_api;
    }
}
```

OpenResty(Lua)可快速实现 JWT 校验、Header 重写与灰度策略。

#### 4.2 Kong（开源网关，插件生态完整）

声明式配置（路由 + JWT + 限流）：

```yaml
_format_version: "3.0"
services:
  - name: user-svc
    url: http://10.0.0.11:8080
    routes:
      - name: user-route
        paths: ["/users"]
        methods: ["GET", "POST"]
        strip_path: false
plugins:
  - name: jwt
    config:
      key_claim_name: kid
      claims_to_verify: ["exp", "nbf"]
  - name: rate-limiting
    config:
      minute: 600
      policy: local
```

#### 4.3 Envoy（L7 代理/边车网关，强大路由与观测）

```yaml
static_resources:
  listeners:
    - name: http_listener
      address: { socket_address: { address: 0.0.0.0, port_value: 8080 } }
      filter_chains:
        - filters:
            - name: envoy.filters.network.http_connection_manager
              typed_config:
                "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
                stat_prefix: ingress_http
                route_config:
                  virtual_hosts:
                    - name: backend
                      domains: ["*"]
                      routes:
                        - match: { prefix: "/api" }
                          route: { cluster: svc_api, timeout: 5s }
                http_filters:
                  - name: envoy.filters.http.router
  clusters:
    - name: svc_api
      connect_timeout: 1s
      type: STRICT_DNS
      load_assignment:
        cluster_name: svc_api
        endpoints:
          - lb_endpoints:
              - endpoint: { address: { socket_address: { address: "svc-api.default.svc", port_value: 8080 } } }
```

#### 4.4 Spring Cloud Gateway（Java 栈）

```java
// Java DSL: 路由 + 断言 + 过滤器（限流/鉴权可通过Filter或与OAuth2集成）
@Bean
RouteLocator routes(RouteLocatorBuilder builder) {
  return builder.routes()
    .route("user_route", r -> r.path("/users/**")
      .filters(f -> f.stripPrefix(1)
                     .requestRateLimiter(c -> c.setRateLimiter(redisRateLimiter())
                     )
      )
      .uri("http://user-svc:8080"))
    .build();
}
```

#### 4.5 公有云 API Gateway（托管方案）

- 统一鉴权（Cognito/Apig/STS）、WAF、全托管限流与配额、按量付费
- 典型：AWS API Gateway、阿里云 API 网关、GCP API Gateway、Azure APIM
- 适合“轻后端/重前端/Serverless”与快速对外开放 API

---

### 5. 常见能力配置速查

- 鉴权：JWT（签名/过期/刷新）、OAuth2（授权码/客户端凭证）、API Key、mTLS
- 限流：IP/用户/令牌桶、突发控制、配额（月/日）
- 重试/超时：GET 幂等重试，指数退避；合理设置上游超时
- CORS：只对可信域名放开，限制方法与头；预检缓存
- 请求校验：大小限制、Schema 校验(JSON Schema/OpenAPI)
- 观测：结构化访问日志、延迟/错误率/流量指标、TraceId 透传
- 安全：WAF/黑白名单、敏感字段脱敏、响应头安全策略（HSTS、X-Frame-Options、CSP）

---

### 6. 最佳实践与常见误区

最佳实践

- 设计优先：以 OpenAPI/AsyncAPI 为契约驱动路由与校验
- 环境分层：dev/staging/prod 隔离，灰度/金丝雀策略标准化
- 策略外置：限流/路由/鉴权策略可配置、可下发、可回滚
- 全链路观测：接入日志、指标、Trace 三件套，问题可观测可定位
- 安全默认开启：最低权限、最小暴露面、默认拒绝、零信任接入
- 自动化：CI/CD 自动发布与回滚，变更审计与配置版本化

常见误区

- 全都塞进网关：复杂业务编排/重业务逻辑不宜进网关，保持“轻逻辑、重治理”
- 单点：网关未做 HA/多 AZ/多 Region，成为瓶颈与单点
- 无契约：无 API 契约导致变更不可控、前后端耦合
- 只做转发：缺少鉴权、限流、观测与审计，难以运维与合规

---

### 7. 学习与实践

动手练习

- 用 Nginx 完成基本路由+限流+CORS
- 用 Kong 配置 JWT 与按用户限流
- 用 Envoy 接入 Prometheus 并查看请求指标
- 用 Spring Cloud Gateway 为某微服务提供灰度路由

工具与生态

- 开源网关：Kong、Apache APISIX、Tyk、KrakenD、Traefik、Envoy、Spring Cloud Gateway
- 契约与测试：OpenAPI/Swagger、Insomnia、Postman
- 观测：Prometheus/Grafana、ELK/Opensearch、Jaeger/Zipkin

---

### 8. 小结

- API 网关以“统一入口+横切能力”解决多端接入与微服务治理难题
- 以“最小可用能力”优先：路由、鉴权、限流、观测与安全
- 与负载均衡/服务网格/BFF 配合使用，边界清晰、职责单一
